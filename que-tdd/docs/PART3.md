## 테스트 주도 개발의 패턴
* 기본적인 전략에 관한 질문
1. 테스트한다는 것은 무엇을 뜻하는가?
2. 테스트를 언제 해야 하는가?
3. 테스트할 로직을 어떻게 고를 것인가?
4. 테스트할 데이터를 어덯게 고를 것인가?

### 25. 테스트 주도 개발 패턴
* 테스트(명사) <br>

Q. 작성한 소프트웨어를 어떻게 테스트할 것인가? <br>
A. 자동화된 테스트를 만들어라. <br>

당신이 변화를 테스트할 수 있다고 해도, 실제로 변화를 테스트하는 것은 '테스트를 갖고 있다'는 것과 똑같지 않다. <br>
테스트는 또한 '승인 또는 거부에 도달하는 과정'을 뜻하는 명사기도 하다. 어째서 명사로서의 테스트(자동으로 실행되는 과정)가 <br>
동사로서의 테스트(버튼을 몇 개 눌러보고 화면에 나오는 결과를 주시하는)와 다른 느낌을 주는 걸까? <br>

<img width="40%" src="https://user-images.githubusercontent.com/55771326/177037329-fbea693f-20fe-4872-92ee-95eab20ba4a4.png"><br>
'테스트할 시간이 없다'의 죽음의 나선 <br>
스트레스를 받으면 테스트를 덜 하게 됨 -> 테스트를 덜하면 에러가 많아진다. -> 에러가 많으지면 다시 빡친다 <br>
이러한 비셔스 사이클을 벗어나기 위해 '테스트'를 '자동화된 테스트'로 치환하면 된다.<br>

<br>

* 격리된 테스트 <br>

Q. 테스트를 실행하는 것이 서로 어떤 식으로 영향을 미쳐야 좋은가? <br>
A. 아무 영향이 없어야 한다. <br>

테스트는 전체 애플리케이션을 대상으로 하는 것보다 좀더 작은 스케일로 하는 게 좋다.<br>
테스트는 다른 테스트와 완전히 독립적이어야 한다. 즉 문제가 하나면 테스트도 하나만 실패해야 하고,<br>
문제가 둘이면 테스트도 두 개만 실패해야 한다.<br>

<br>

* 테스트 목록 <br>

Q. 뭘 테스트해야 하나? <br> 
A. 시작하기 전에 작성해야 할 테스트 목록을 모두 적어둘 것. <br>

1. 구현할 필요가 있는 모든 오퍼레이션의 사용예들을 적는다.
2. 이미 존재하지 않는 오퍼레이션에 대해서는 해당 오퍼레이션 널 버전을 리스트에 적는다.
3. 깔끔한 코드를 얻기 위해 이번 작업을 끝내기 전에 반드시 해야 할 리팩토링 목록을 적는다.

제대로 작동하지 않는 테스트를 하나라도 생각할 수 있다면, 그걸 제대로 되게 하는 것이 코드를 릴리즈하는 것보다 더 중요하다.<br>

<br>

* 테스트 우선 <br>

Q. 테스트를 언제 작성하는 것이 좋을까? <br>
A. 테스트 대상이 되는 코드를 작성하기 직전에 작성하는 것이 좋다.<br>

테스트를 먼저 하면 스트레스가 줄고, 따라서 테스트를 더 많이 하게 된다. 하지만 <br>
스트레스를 유발하는 다른 원인들이 많기 때문에 테스트는 또 다른 효과적인 주기의 <br>
영향도 함께 받아야 할 것이다. <br>

<br>

* 단언 우선 <br>

Q. 테스트를 작성할 때 단언(assert)은 언제쯤 쓸까? <br>
A. 단언을 제일 먼저 쓰고 시작하라. <br>

단언을 먼저 작성하면 작업을 단순하게 만드는 강력한 효과를 볼 수 있다. <br>
구현에 대해 전혀 고려하지 않고 테스트만 작성할 때도 몇 가지 문제들을 한번에 해결할 수 있다 <br>
1. 테스트하고자 하는 기능이 어디에 속하는 걸까?
2. 메소드 이름은 뭐라고 해야 하나?
3. 올바른 결과를 어떤 식으로 검사할 것인가?
4. 이 테스트가 제안하는 또 다른 테스트에는 뭐가 있을까?

<br>

* 테스트 데이터 <br>

Q. 테스트할 때 어떤 데이터를 사용해야 하는가? <br>
A. 테스트를 읽을 때 쉽고 따라가기 좋을 만한 데이터를 사용하라. <br>

테스트 데이터에 대한 대안은 실제 세상에서 얻어진 실제 데이터를 사용하는 것이다. <br>
실제 데이터는 다음과 같은 경우에 유용하다.<br>
1. 실제 실행을 통해 수집한 외부 이벤트의 결과를 이용하여 실시간 시스템을 테스트하고자 하는 경우.
2. 예전 시스템의 출력과 현재 시스템의 출력을 비교하고자 하는 경우.
3. 시뮬레이션 시스템을 리팩토링한 후 기존과 정확히 동일한 결과가 나오는지 확인하고자 할 경우.

<br>

* 명백한 데이터 <br>

Q. 데이터의 의도를 어떻게 표현할 것인가? <br>
A. 테스트 자체에 예상되는 값과 실제 값을 포함하고 이 둘 사이의 관계를 드러내기 위해 노력하라. <br>

테스트를 작성할 때는 컴퓨터뿐 아니라 후에 코드를 읽을 다른 사람들도 생각해야 한다. <br>
명백한 데이터가 주는 또 다른 이점은 프로그래밍이 더 쉬워진다는 것이다. <br>

<br>


### 26. 빨간 막대 패턴

* 한 단계 테스트 <br>

Q. 목록에서 다음 테스트를 고를 때 무엇을 기준으로 할 것인가? <br>
A. 여러분에게 새로운 무언가를 가르쳐 줄 수 있으며, 구현할 수 있다는 확신이 드는 테스트를 고를 것. <br>

첫째로, 성장(growth)이란 단어를 보자. <br>
'성장'은 일종의 자기 유사성을 가진 피드백 고리를 암시하는데, 이 피드백 고리에서는 환경이 프로그램에 영향을 주고 프로그램이 다시 환경에 영향을 준다. <br>
둘째로, '아는 것에서 모르는 것으로(known-to-unknown)'라는 방향이 유용할 것이다. <br>
우리가 어느 정도의 지식과 경험을 가지고 개발을 시작한다는 점, 개발하는 중에 새로운 것을 배우게 될 것임을 예상한다는 점 등을 암시한다. <br>

<br>

* 시작 테스트 <br>

Q. 어떤 테스트부터 시작하는 게 좋을까? <br>
A. 오퍼레이션이 아무 일도 하지 않는 경우를 먼저 테스트할 것 <br>

1. 이 오퍼레이션을 어디에 두어야 하나?
2. 적절한 입력 값은 무엇인가?
3. 이 입력들이 주어졌을 때 적절한 출력은 무엇인가?


당신에게 뭔가를 가르쳐 줄 수 있으면서도 빠르게 구현할 수 있는 테스트를 선택하라. <br>

<br>

* 설명 테스트 <br>

Q. 자동화된 테스트가 더 널리 쓰이게 하려면 어떻게 해야 할까? <br>
A. 테스트를 통해 설명을 요청하고 테스트를 통해 설명하라. <br>

어떻게 해야 하나? 단순한 시작법은 테스트를 이용하여 묻고, 테스트를 이용하여 설명하는 것이다. <br>

<br>

* 학습 테스트 <br>

Q. 외부에서 만든 소프트웨어에 대한 테스트를 작성해야 할 때도 있을까? <br>
A. 패키지의 새로운 기능을 처음으로 사용해보기 전에 작성할 수 있다 <br>

이제 막 새 클래스의 새 메서드를 하나 사용한다는 것을 아채는 것이다. <br>
그냥 바로 사용하는 대신 API가 우리 예상대로 실행된다는 것을 확인해줄 만한 작은 테스트를 만들어 보는 것이다. <br>
만약 테스트가 통과되지 않는다면 애플리케이션 역시 실행되지 않을 것이 번하기 때문에 애플리케이션을 실행해볼 필요도 없다. <br>
일단 테스트가 통과한다면 애플리케이션은 항상 제대로 돌아갈 것이다. <br>

<br>

* 또 다른 테스트 <br>

Q. 어떻게 하면 주제에서 벗어나지 않고 기술적인 논의를 계속할 수 있을까? <br>
A. 주제와 무관한 아이디어가 떠오르면 이에 대한 테스트를 할일 목록에 적어놓고 다시 주제로 돌아올 것 <br>

새 아이디어가 떠오르면 존중하고 맞이하되 그것이 내 주의를 흩뜨리지 않게 한다. <br>
그 아이디어를 리스트에 적어놓고는 하던 일로 다시 돌아간다. <br>

<br>

* 회귀 테스트 <br>

Q. 시스템 장애가 보고될 때 여러분은 무슨 일을 제일 먼저 하는가? <br>
A. 그 장애로 인하여 실패하는 테스트, 그리고 통과할 경우엔 장애가 수정되었다고 볼 수 있는 테스트를 가장 간단하게 작성하라. <br>

**회귀 테스트(regression test)란**, 사실 여러분에게 완벽한 선견지명이 있다면, 처음 코딩할 때 작성했어야 하는 테스트다. <br>
회귀 테스트를 작성할때는 이 테스트를 작성해야 한다는 사실을 어떻게 하면 애초에 알 수 있었을지 항상 생각해보라. <br>
애플리케이션 차원의 회귀 테스트는 시스템의 사용자들이 여러분에게 정확히 무엇을 기대했으며 무엇이 잘못되었는지 말할 기회를 준다. <br>
좀더 작은 차원에서 회귀 테스트는 당신의 테스트를 개선하는 방법이 된다. 시스템 장애를 손쉽게 격리시킬 수 없다면 리팩토링해야 한다.<br>

<br>

* 휴식 <br>

Q. 지치고 고난에 빠졌을 땐 뭘 해야 하나? <br>
A. 그럴 땐 좀 쉬는게 좋다. <br>

1. 시간 단위로는, 물병을 키보드 옆에 두어서 생리 현상으로 규칙적인 휴식을 하도록 유도하라.
2. 하루 단위로는, 더 진행하기 전에 잠이 필요한 경우 정규 근무 시간후의 약속이 진행을 일단 멈추는 데에 도움이 될 수 있다.
3. 주 단위로는, 의식적이고 에너지 소모적인 업무 관련 생각을 떨쳐버리는 데에 주말 활동이 도움이 된다.
4. 년 단위로는, 강제 휴가 정책이 여러분의 재충전을 완벽히 도와줄 것이다.

<br>

* 다시 하기 <br>

Q. 길을 읽은 느낌이 들 땐 어떻게 할까? <br>
A. 코드를 다 지워버리고 처음부터 다시 해보자. <br>

<br>

* 싸구려 책상, 좋은 의자 <br>

Q. TDD를 할 때 어떤 물리적 환경이 적절한가? <br>
A. 나머지 시설은 싸구려를 쓸지라도 정말 좋은 의자를 구해라. <br>

<br>

### 27. 테스팅 패턴

* 자식 테스트 <br>

Q. 지나치게 큰 테스트 케이스를 어떻게 돌아가도록 할 수 있을까? <br>
A. 원래 테스트 케이스의 깨지는 부분에 해당하는 작은 테스트 케이스를 작성하고 그 작은 테스트 케이스가 실행되도록 하라. <br>

빨강/초록/리팩토링 리듬은 성공이 지속되는 데 너무나도 중요해서, <br>
그 리듬을 잃어버릴 것 같은 위기 순간에 부가의 노력으로 리듬을 유지하는 것이 충분히 가치 있다. <br>

<br>

* 모의 객체 <br>

Q. 비용이 많이 들거나 복잡한 리소스에 의존하는 객체를 테스트하려면 어떻게 해야 할까? <br>
A. 상수를 반환하게끔 만든 속임수 버전의 리소스를 만들면 된다. <br>

모의 객체는 당신이 모든 객체의 가시성에 대해 고민하도록 격려해서, 설계에서 커플링이 감소하도록 한다. <br>
모의 객체를 사용하면 프로젝트에 위험 요소가 하나 추가된다. 모의 객체가 진짜 객체와 동일하게 동작하지 않으면 어떻게 될까? <br>
모의 객체용 테스트 집합을 진짜 객체가 사용 가능해질 때 그대로 적용해서 이러한 위험을 줄일 수 있다. <br>

<br>

* 셀프 션트 <br>

Q. 한 객체가 다른 객체와 올바르게 대화하는지 테스트하려면 어떻게 할까? <br>
A. 테스트 대상이 되는 객체가 원래의 대화 상대가 아니라 테스트 케이스와 대화하도록 만들면 된다. <br>

셀프 션트 패턴은 테스트 케이스가 구현할 인터페이스를 얻기 위해 인터페이스 추출을 해야 한다. <br>
인터페이스를 추출하는 것이 더 쉬운지, 존재하는 클래스를 블랙 박스로 테스트하는 것이 더 쉬운지는 당신이 결정해야 할 것이다. <br>

<br>

* 로그 문자열 <br>

Q. 메시지의 호출 순서가 올바른지를 검사하려면 어떻게 해야 할까? <br>
A. 로그 문자열을 가지고 있다가 메시지가 호출될 때마다 그 문자열에 추가하도록 한다. <br>

로그 문자열은 특히 옵저버를 구현하고, 이벤트 통보가 원하는 순서대로 발생하는지를 확인하고자 할 때 유용하다. <br>
만약 어떤 이벤트 통보들이 일어나는지를 검사하기는 하지만 그 순서는 상관이 없을 경우엔 문자열 집합을 저장하고 <br>
있다가 단언에서 집합 비교를 수행하면 된다. <br>

<br>

* 크래시 테스트 더미 <br>

Q. 호출되지 않을 것 같은 에러 코드를 어떻게 테스트할 것인가? <br>
A. 실제 작업을 수행하는 대신 그냥 예외를 발생시키기만 하는 특수한 객체를 만들어서 이를 호출한다. <br.

객체 전체를 흉내낼 필요가 없다는 점을 제외하면 크래시 테스트 더미는 모의 객체와 유사하다. <br>
자바의 익명 내부 클래스는 우리가 테스트하기 원하는 적절한 메서드만이 오류를 발생시키게끔 하기 위해 유용하게 쓰인다. <br>

<br>

* 깨진 테스트 <br>

Q. 혼자서 프로그래밍할 때 프로그래밍 세션을 어떤 상태로 끝마치는 게 좋을까? <br>
A. 마지막 테스트가 깨진 상태로 끝마치는 것이 좋다. <br>

프로그래밍 세션을 끝낼 때 테스트 케이스를 작성하고 이것이 실패하는 것을 확실히 확인하는 것이다. <br>
나중에 다시 코딩하기 위해 돌아왔을 때, 어느 작업부터 시작할 것인지 명백히 알 수 있다. <br>

<br>

* 깨끗한 체크인 <br>

Q. 팀 프로그래밍을 할 때 프로그래밍 세션을 어떤 상태로 끝마치는 게 좋을까? <br>
A. 모든 테스트가 성공한 상태로 끝마치는 것이 좋다. <br>

팀 프로젝트에서 프로그래밍 세션을 시작하는 경우라면 자신이 마지막으로 코딩한 다음부터 지금까지 무슨 일이 있었는지 세밀하게 알 수 없다. <br>
안심되고 확신이 있는 상태에서 시작할 필요가 있다. 다라서 코드를 체크인하기 전에 항상 모든 테스트가 돌아가는 상태로 만들어 두어야 한다. <br>

### 28. 초록 막대 패턴

* 가짜로 구현하기(진짜로 만들기 전까지만)

Q. 실패하는 테스트를 만든 후 첫 번째 구현은 어떻게 하는게 좋을까? <br>
A. 상수를 반환하게 하라. <br>

가짜로 구현하기를 강력하게 만드는 두 가지 효과가 있다. <br>
1. 심리학적 : 초록 막대 상태에 있는것은 빨간 막대 상태에 있는 것과 천지 차이다. 막대가 초록색일 때, 자신이 어디에 서 있는지 안다. 
2. 범위조절 : 다음 테스트 케이스를 구현할 때, 이전 테스트의 작동이 보장된다는 것을 알기 때문에 그 다음 테스트 케이스에도 집중할 수 있다.

<br>

* 삼각 측량 <br>

Q. 추상화 과정을 테스트로 주도할 때 어떻게 최대한 보수적으로 할 수 있겠는가? <br>
A. 오로지 예가 두 개 이상일 때에만 추상화를 하라. <br>

삼각측량이 매력적인 이유는 그 규칙이 매우 명확하기 때문이다. 가짜로 구현하기를 위한 규칙들은, 추상을 끌어내기 위한 가짜 구현과 <br>
테스트 케이스 사이의 중복에 대한 우리 감각에 의존하는 것으로, 약간 모호해 보이고 달리 해석될 수 있다. 삼각측량의 법칙들이 비록 <br>
단순해 보이기는 하지만 그것은 무한 루프를 만들어 낸다.<br>

<br>

* 명백한 구현 <br>

Q. 단순한 연산들을 어떻게 구현하는가? <br>
A. 그냥 구현해 버려라. <br>

가짜로 구현하기와 삼각측량의 어중간한 성질에 특별한 미덕이 있는 것은 아니다. 뭘 타이핑해야 할지 알고, 그걸 재빨리 할 수 있다면 그냥 해버려라. <br>
하지만, '제대로 동작하는'을 푸는 동시에 '깨끗한 코드'를 해결하려는 것은 한번에 하기에는 너무 많은 일일 수 있다. 그렇게 되면 우선 '제대로 동작 하는' <br>
으로 되돌아 가서 그걸 해결하고, 그 후에 '깨끗한 코드'를 느긋하게 해결하도록 하라. <br>

<br>

* 하나에서 여럿으로 <br>

Q. 객체 컬렉션을 다루는 연산은 어떻게 구현하나? <br>
A. 일단 컬렉션없이 구현하고 그 다음에 컬렉션을 사용하게 한다. <br>
