## 테스트 주도 개발의 패턴

* 기본적인 전략에 관한 질문

1. 테스트한다는 것은 무엇을 뜻하는가?
2. 테스트를 언제 해야 하는가?
3. 테스트할 로직을 어떻게 고를 것인가?
4. 테스트할 데이터를 어덯게 고를 것인가?

### 25. 테스트 주도 개발 패턴

* 테스트(명사) <br>

Q. 작성한 소프트웨어를 어떻게 테스트할 것인가? <br>
A. 자동화된 테스트를 만들어라. <br>

당신이 변화를 테스트할 수 있다고 해도, 실제로 변화를 테스트하는 것은 '테스트를 갖고 있다'는 것과 똑같지 않다. <br>
테스트는 또한 '승인 또는 거부에 도달하는 과정'을 뜻하는 명사기도 하다. 어째서 명사로서의 테스트(자동으로 실행되는 과정)가 <br>
동사로서의 테스트(버튼을 몇 개 눌러보고 화면에 나오는 결과를 주시하는)와 다른 느낌을 주는 걸까? <br>

<img width="40%" src="https://user-images.githubusercontent.com/55771326/177037329-fbea693f-20fe-4872-92ee-95eab20ba4a4.png"><br>
'테스트할 시간이 없다'의 죽음의 나선 <br>
스트레스를 받으면 테스트를 덜 하게 됨 -> 테스트를 덜하면 에러가 많아진다. -> 에러가 많으지면 다시 빡친다 <br>
이러한 비셔스 사이클을 벗어나기 위해 '테스트'를 '자동화된 테스트'로 치환하면 된다.<br>

<br>

* 격리된 테스트 <br>

Q. 테스트를 실행하는 것이 서로 어떤 식으로 영향을 미쳐야 좋은가? <br>
A. 아무 영향이 없어야 한다. <br>

테스트는 전체 애플리케이션을 대상으로 하는 것보다 좀더 작은 스케일로 하는 게 좋다.<br>
테스트는 다른 테스트와 완전히 독립적이어야 한다. 즉 문제가 하나면 테스트도 하나만 실패해야 하고,<br>
문제가 둘이면 테스트도 두 개만 실패해야 한다.<br>

<br>

* 테스트 목록 <br>

Q. 뭘 테스트해야 하나? <br>
A. 시작하기 전에 작성해야 할 테스트 목록을 모두 적어둘 것. <br>

1. 구현할 필요가 있는 모든 오퍼레이션의 사용예들을 적는다.
2. 이미 존재하지 않는 오퍼레이션에 대해서는 해당 오퍼레이션 널 버전을 리스트에 적는다.
3. 깔끔한 코드를 얻기 위해 이번 작업을 끝내기 전에 반드시 해야 할 리팩토링 목록을 적는다.

제대로 작동하지 않는 테스트를 하나라도 생각할 수 있다면, 그걸 제대로 되게 하는 것이 코드를 릴리즈하는 것보다 더 중요하다.<br>

<br>

* 테스트 우선 <br>

Q. 테스트를 언제 작성하는 것이 좋을까? <br>
A. 테스트 대상이 되는 코드를 작성하기 직전에 작성하는 것이 좋다.<br>

테스트를 먼저 하면 스트레스가 줄고, 따라서 테스트를 더 많이 하게 된다. 하지만 <br>
스트레스를 유발하는 다른 원인들이 많기 때문에 테스트는 또 다른 효과적인 주기의 <br>
영향도 함께 받아야 할 것이다. <br>

<br>

* 단언 우선 <br>

Q. 테스트를 작성할 때 단언(assert)은 언제쯤 쓸까? <br>
A. 단언을 제일 먼저 쓰고 시작하라. <br>

단언을 먼저 작성하면 작업을 단순하게 만드는 강력한 효과를 볼 수 있다. <br>
구현에 대해 전혀 고려하지 않고 테스트만 작성할 때도 몇 가지 문제들을 한번에 해결할 수 있다 <br>

1. 테스트하고자 하는 기능이 어디에 속하는 걸까?
2. 메소드 이름은 뭐라고 해야 하나?
3. 올바른 결과를 어떤 식으로 검사할 것인가?
4. 이 테스트가 제안하는 또 다른 테스트에는 뭐가 있을까?

<br>

* 테스트 데이터 <br>

Q. 테스트할 때 어떤 데이터를 사용해야 하는가? <br>
A. 테스트를 읽을 때 쉽고 따라가기 좋을 만한 데이터를 사용하라. <br>

테스트 데이터에 대한 대안은 실제 세상에서 얻어진 실제 데이터를 사용하는 것이다. <br>
실제 데이터는 다음과 같은 경우에 유용하다.<br>

1. 실제 실행을 통해 수집한 외부 이벤트의 결과를 이용하여 실시간 시스템을 테스트하고자 하는 경우.
2. 예전 시스템의 출력과 현재 시스템의 출력을 비교하고자 하는 경우.
3. 시뮬레이션 시스템을 리팩토링한 후 기존과 정확히 동일한 결과가 나오는지 확인하고자 할 경우.

<br>

* 명백한 데이터 <br>

Q. 데이터의 의도를 어떻게 표현할 것인가? <br>
A. 테스트 자체에 예상되는 값과 실제 값을 포함하고 이 둘 사이의 관계를 드러내기 위해 노력하라. <br>

테스트를 작성할 때는 컴퓨터뿐 아니라 후에 코드를 읽을 다른 사람들도 생각해야 한다. <br>
명백한 데이터가 주는 또 다른 이점은 프로그래밍이 더 쉬워진다는 것이다. <br>

<br>

### 26. 빨간 막대 패턴

* 한 단계 테스트 <br>

Q. 목록에서 다음 테스트를 고를 때 무엇을 기준으로 할 것인가? <br>
A. 여러분에게 새로운 무언가를 가르쳐 줄 수 있으며, 구현할 수 있다는 확신이 드는 테스트를 고를 것. <br>

첫째로, 성장(growth)이란 단어를 보자. <br>
'성장'은 일종의 자기 유사성을 가진 피드백 고리를 암시하는데, 이 피드백 고리에서는 환경이 프로그램에 영향을 주고 프로그램이 다시 환경에 영향을 준다. <br>
둘째로, '아는 것에서 모르는 것으로(known-to-unknown)'라는 방향이 유용할 것이다. <br>
우리가 어느 정도의 지식과 경험을 가지고 개발을 시작한다는 점, 개발하는 중에 새로운 것을 배우게 될 것임을 예상한다는 점 등을 암시한다. <br>

<br>

* 시작 테스트 <br>

Q. 어떤 테스트부터 시작하는 게 좋을까? <br>
A. 오퍼레이션이 아무 일도 하지 않는 경우를 먼저 테스트할 것 <br>

1. 이 오퍼레이션을 어디에 두어야 하나?
2. 적절한 입력 값은 무엇인가?
3. 이 입력들이 주어졌을 때 적절한 출력은 무엇인가?

당신에게 뭔가를 가르쳐 줄 수 있으면서도 빠르게 구현할 수 있는 테스트를 선택하라. <br>

<br>

* 설명 테스트 <br>

Q. 자동화된 테스트가 더 널리 쓰이게 하려면 어떻게 해야 할까? <br>
A. 테스트를 통해 설명을 요청하고 테스트를 통해 설명하라. <br>

어떻게 해야 하나? 단순한 시작법은 테스트를 이용하여 묻고, 테스트를 이용하여 설명하는 것이다. <br>

<br>

* 학습 테스트 <br>

Q. 외부에서 만든 소프트웨어에 대한 테스트를 작성해야 할 때도 있을까? <br>
A. 패키지의 새로운 기능을 처음으로 사용해보기 전에 작성할 수 있다 <br>

이제 막 새 클래스의 새 메서드를 하나 사용한다는 것을 아채는 것이다. <br>
그냥 바로 사용하는 대신 API가 우리 예상대로 실행된다는 것을 확인해줄 만한 작은 테스트를 만들어 보는 것이다. <br>
만약 테스트가 통과되지 않는다면 애플리케이션 역시 실행되지 않을 것이 번하기 때문에 애플리케이션을 실행해볼 필요도 없다. <br>
일단 테스트가 통과한다면 애플리케이션은 항상 제대로 돌아갈 것이다. <br>

<br>

* 또 다른 테스트 <br>

Q. 어떻게 하면 주제에서 벗어나지 않고 기술적인 논의를 계속할 수 있을까? <br>
A. 주제와 무관한 아이디어가 떠오르면 이에 대한 테스트를 할일 목록에 적어놓고 다시 주제로 돌아올 것 <br>

새 아이디어가 떠오르면 존중하고 맞이하되 그것이 내 주의를 흩뜨리지 않게 한다. <br>
그 아이디어를 리스트에 적어놓고는 하던 일로 다시 돌아간다. <br>

<br>

* 회귀 테스트 <br>

Q. 시스템 장애가 보고될 때 여러분은 무슨 일을 제일 먼저 하는가? <br>
A. 그 장애로 인하여 실패하는 테스트, 그리고 통과할 경우엔 장애가 수정되었다고 볼 수 있는 테스트를 가장 간단하게 작성하라. <br>

**회귀 테스트(regression test)란**, 사실 여러분에게 완벽한 선견지명이 있다면, 처음 코딩할 때 작성했어야 하는 테스트다. <br>
회귀 테스트를 작성할때는 이 테스트를 작성해야 한다는 사실을 어떻게 하면 애초에 알 수 있었을지 항상 생각해보라. <br>
애플리케이션 차원의 회귀 테스트는 시스템의 사용자들이 여러분에게 정확히 무엇을 기대했으며 무엇이 잘못되었는지 말할 기회를 준다. <br>
좀더 작은 차원에서 회귀 테스트는 당신의 테스트를 개선하는 방법이 된다. 시스템 장애를 손쉽게 격리시킬 수 없다면 리팩토링해야 한다.<br>

<br>

* 휴식 <br>

Q. 지치고 고난에 빠졌을 땐 뭘 해야 하나? <br>
A. 그럴 땐 좀 쉬는게 좋다. <br>

1. 시간 단위로는, 물병을 키보드 옆에 두어서 생리 현상으로 규칙적인 휴식을 하도록 유도하라.
2. 하루 단위로는, 더 진행하기 전에 잠이 필요한 경우 정규 근무 시간후의 약속이 진행을 일단 멈추는 데에 도움이 될 수 있다.
3. 주 단위로는, 의식적이고 에너지 소모적인 업무 관련 생각을 떨쳐버리는 데에 주말 활동이 도움이 된다.
4. 년 단위로는, 강제 휴가 정책이 여러분의 재충전을 완벽히 도와줄 것이다.

<br>

* 다시 하기 <br>

Q. 길을 읽은 느낌이 들 땐 어떻게 할까? <br>
A. 코드를 다 지워버리고 처음부터 다시 해보자. <br>

<br>

* 싸구려 책상, 좋은 의자 <br>

Q. TDD를 할 때 어떤 물리적 환경이 적절한가? <br>
A. 나머지 시설은 싸구려를 쓸지라도 정말 좋은 의자를 구해라. <br>

<br>

### 27. 테스팅 패턴

* 자식 테스트 <br>

Q. 지나치게 큰 테스트 케이스를 어떻게 돌아가도록 할 수 있을까? <br>
A. 원래 테스트 케이스의 깨지는 부분에 해당하는 작은 테스트 케이스를 작성하고 그 작은 테스트 케이스가 실행되도록 하라. <br>

빨강/초록/리팩토링 리듬은 성공이 지속되는 데 너무나도 중요해서, <br>
그 리듬을 잃어버릴 것 같은 위기 순간에 부가의 노력으로 리듬을 유지하는 것이 충분히 가치 있다. <br>

<br>

* 모의 객체 <br>

Q. 비용이 많이 들거나 복잡한 리소스에 의존하는 객체를 테스트하려면 어떻게 해야 할까? <br>
A. 상수를 반환하게끔 만든 속임수 버전의 리소스를 만들면 된다. <br>

모의 객체는 당신이 모든 객체의 가시성에 대해 고민하도록 격려해서, 설계에서 커플링이 감소하도록 한다. <br>
모의 객체를 사용하면 프로젝트에 위험 요소가 하나 추가된다. 모의 객체가 진짜 객체와 동일하게 동작하지 않으면 어떻게 될까? <br>
모의 객체용 테스트 집합을 진짜 객체가 사용 가능해질 때 그대로 적용해서 이러한 위험을 줄일 수 있다. <br>

<br>

* 셀프 션트 <br>

Q. 한 객체가 다른 객체와 올바르게 대화하는지 테스트하려면 어떻게 할까? <br>
A. 테스트 대상이 되는 객체가 원래의 대화 상대가 아니라 테스트 케이스와 대화하도록 만들면 된다. <br>

셀프 션트 패턴은 테스트 케이스가 구현할 인터페이스를 얻기 위해 인터페이스 추출을 해야 한다. <br>
인터페이스를 추출하는 것이 더 쉬운지, 존재하는 클래스를 블랙 박스로 테스트하는 것이 더 쉬운지는 당신이 결정해야 할 것이다. <br>

<br>

* 로그 문자열 <br>

Q. 메시지의 호출 순서가 올바른지를 검사하려면 어떻게 해야 할까? <br>
A. 로그 문자열을 가지고 있다가 메시지가 호출될 때마다 그 문자열에 추가하도록 한다. <br>

로그 문자열은 특히 옵저버를 구현하고, 이벤트 통보가 원하는 순서대로 발생하는지를 확인하고자 할 때 유용하다. <br>
만약 어떤 이벤트 통보들이 일어나는지를 검사하기는 하지만 그 순서는 상관이 없을 경우엔 문자열 집합을 저장하고 <br>
있다가 단언에서 집합 비교를 수행하면 된다. <br>

<br>

* 크래시 테스트 더미 <br>

Q. 호출되지 않을 것 같은 에러 코드를 어떻게 테스트할 것인가? <br>
A. 실제 작업을 수행하는 대신 그냥 예외를 발생시키기만 하는 특수한 객체를 만들어서 이를 호출한다. <br.

객체 전체를 흉내낼 필요가 없다는 점을 제외하면 크래시 테스트 더미는 모의 객체와 유사하다. <br>
자바의 익명 내부 클래스는 우리가 테스트하기 원하는 적절한 메서드만이 오류를 발생시키게끔 하기 위해 유용하게 쓰인다. <br>

<br>

* 깨진 테스트 <br>

Q. 혼자서 프로그래밍할 때 프로그래밍 세션을 어떤 상태로 끝마치는 게 좋을까? <br>
A. 마지막 테스트가 깨진 상태로 끝마치는 것이 좋다. <br>

프로그래밍 세션을 끝낼 때 테스트 케이스를 작성하고 이것이 실패하는 것을 확실히 확인하는 것이다. <br>
나중에 다시 코딩하기 위해 돌아왔을 때, 어느 작업부터 시작할 것인지 명백히 알 수 있다. <br>

<br>

* 깨끗한 체크인 <br>

Q. 팀 프로그래밍을 할 때 프로그래밍 세션을 어떤 상태로 끝마치는 게 좋을까? <br>
A. 모든 테스트가 성공한 상태로 끝마치는 것이 좋다. <br>

팀 프로젝트에서 프로그래밍 세션을 시작하는 경우라면 자신이 마지막으로 코딩한 다음부터 지금까지 무슨 일이 있었는지 세밀하게 알 수 없다. <br>
안심되고 확신이 있는 상태에서 시작할 필요가 있다. 다라서 코드를 체크인하기 전에 항상 모든 테스트가 돌아가는 상태로 만들어 두어야 한다. <br>

### 28. 초록 막대 패턴

* 가짜로 구현하기(진짜로 만들기 전까지만)

Q. 실패하는 테스트를 만든 후 첫 번째 구현은 어떻게 하는게 좋을까? <br>
A. 상수를 반환하게 하라. <br>

가짜로 구현하기를 강력하게 만드는 두 가지 효과가 있다. <br>

1. 심리학적 : 초록 막대 상태에 있는것은 빨간 막대 상태에 있는 것과 천지 차이다. 막대가 초록색일 때, 자신이 어디에 서 있는지 안다.
2. 범위조절 : 다음 테스트 케이스를 구현할 때, 이전 테스트의 작동이 보장된다는 것을 알기 때문에 그 다음 테스트 케이스에도 집중할 수 있다.

<br>

* 삼각 측량 <br>

Q. 추상화 과정을 테스트로 주도할 때 어떻게 최대한 보수적으로 할 수 있겠는가? <br>
A. 오로지 예가 두 개 이상일 때에만 추상화를 하라. <br>

삼각측량이 매력적인 이유는 그 규칙이 매우 명확하기 때문이다. 가짜로 구현하기를 위한 규칙들은, 추상을 끌어내기 위한 가짜 구현과 <br>
테스트 케이스 사이의 중복에 대한 우리 감각에 의존하는 것으로, 약간 모호해 보이고 달리 해석될 수 있다. 삼각측량의 법칙들이 비록 <br>
단순해 보이기는 하지만 그것은 무한 루프를 만들어 낸다.<br>

<br>

* 명백한 구현 <br>

Q. 단순한 연산들을 어떻게 구현하는가? <br>
A. 그냥 구현해 버려라. <br>

가짜로 구현하기와 삼각측량의 어중간한 성질에 특별한 미덕이 있는 것은 아니다. 뭘 타이핑해야 할지 알고, 그걸 재빨리 할 수 있다면 그냥 해버려라. <br>
하지만, '제대로 동작하는'을 푸는 동시에 '깨끗한 코드'를 해결하려는 것은 한번에 하기에는 너무 많은 일일 수 있다. 그렇게 되면 우선 '제대로 동작 하는' <br>
으로 되돌아 가서 그걸 해결하고, 그 후에 '깨끗한 코드'를 느긋하게 해결하도록 하라. <br>

<br>

* 하나에서 여럿으로 <br>

Q. 객체 컬렉션을 다루는 연산은 어떻게 구현하나? <br>
A. 일단 컬렉션없이 구현하고 그 다음에 컬렉션을 사용하게 한다. <br>

<br>

### 29. xUnit 패턴

* 단언(assertion) <br>

Q. 테스트가 잘 작동하는지 어떻게 검사할 것인가? <br>
A. 불리언 수식을 작성해서 여러분 대신 프로그램이 자동으로 코드가 동작하는지에 대한 판단을 수행하도록 하라. <br>

1. 판단 결과가 불리언 값이어야 한다. 일반적으로 참 값은 모든 테스트가 통과했음을 의미하고, 거짓 값은 뭔가 예상치 못했던 일이 발생했음을 의미한다.
2. 이 불리언 값은 컴퓨터에 의해 검증되어야 한다. 보통 다양한 형태의 assert() 메서드를 호출하여 이 값을 얻어낸다.

<br>

* 픽스처 <br>

Q. 여러 테스트에서 공통으로 사용하는 객체들을 생성할 때 어덯게 하면 좋을까? <br>
A. 각 테스트 코드에 있는 지역 변수를 인스턴스 별수로 바꾸고 setUp() 메서드를 재정의하여 이 메서드에서 인스턴스 변수들을 초기화하도록 한다. <br>

문제는 이렇다. 여러분은 종종 객체들을 우너하는 상태로 세팅하는 코드를 작성하고 나서, <br>
이 객체들을 조작하고 결과를 테스트하는 코드를 만든다. 그런데 객체들을 세팅하는 코드는 여러 테스트에 걸쳐 동일한 경우가 있다. <br>
이와 같은 중복은 다음과 같은 이유로 좋지 않다. <br>

1. 복사해서 붙이기를 한다고 하더라도 이런 코드를 반복 작성하는 것엔 시간이 소요되는데, 우리는 테스트를 빨리 작성하길 원한다.
2. 인터페이스를 수동으로 변경할 필요가 있을 경우, 여러 테스트를 고쳐주어야 한다.

<br>

* 외부 픽스처 <br>

Q. 픽스처 중 외부 자원이 있을 경우 이를 어떻게 해제(release)할 것인가? <br>
A. tearDown() 메서드를 재정의하여 이공에서 자원을 해제하면 된다. <br>

xUnit은 각각의 테스트가 끝난 후에 tearDown()이 호출되는 것을 보장해 준다. <br>
tearDown()은 테스트 메서드에서 무슨 일이 벌어졌건 간에 상관 없이 호출될 것이다. <br>

<br>

* 테스트 메서드 <br>

Q. 테스트 케이스 하나를 어떻게 표현할 것인가? <br>
A. 'test'로 시작하는 이름의 메서드로 나타내면 된다. <br>

JUnit5 나오면서 'test' 시작하지 않아도 된다. <br>

<br>

* 예외 테스트 <br>

Q. 예외가 발생하는 것이 정상인 경우에 대한 테스트는 어떻게 작성할 것인가? <br>
A. 예상되는 예외를 잡아서 무시하고, 예외가 발생하지 않은 경우에 한해서 테스트가 실패하게 만들면 된다. <br>

우리가 워하는 정확한 종류의 예외만을 잡아내야 한다는 점에 유의하기 바란다. <br>
그래야만 우리가 원하는 예외가 아닌, 다른 예외가 발생한 경우 테스트가 적절히 실패할 것이기 때문이다. <br>

<br>

* 전체 테스트 <br>

Q. 모든 테스트를 한번에 실행하려면 어떻게 해야 할까? <br>
A. 모든 테스트 슈트에 대한 모음을 작성하면 된다. <br>

IDE가 패키지 단위로 실행을 도와준다. <br>

<br>

### 30. 디자인 패턴

패턴에 대한 요약 <br>

1. 커맨드 : 계산 작업에 대한 호출을 메시지가 아닌 객체로 표현한다.
2. 값 객체 : 객체가 생성된 이후 그 값이 절대로 변하지 않게 하여 별칭 문제가 발생하지 않게 한다.
3. 널 객체 : 계산 작업의 기본 사례를 객체로 표현한다.
4. 템플릿 메서드 : 계산 작업의 변하지 않는 순서를 여러 추상 메서드로 표현한다. 이 추상 메서드들은 상속을 통해 특별한 작업을 수행하게끔 구체화된다.
5. 플러거블 객체 : 둘 이상의 구현을 객체를 호출함으로써 다양성을 표현한다.
6. 플러거블 셀렉터 : 객체별로 서로 다른 메서드가 동적으로 호출되게 함으로써 필요 없는 하위 클래스의 생성을 피한다.
7. 팩토리 메서드 : 생성자 대신 메서드를 호출함으로써 객체를 생성한다.
8. 임포스터 : 현존하는 프로토콜을 갖는 다른 구현을 추가하여 시스템에 변이를 도입한다.
9. 컴포지트 : 하나의 객체로 여러 객체의 행위 조합을 표현한다.
10. 수집 매개 변수 : 여러 다른 객체에서 계산한 결과를 모으기 위해 매개 변수를 여러 곳으로 전달한다.

<br>

* 테스트 주도 개발에서 디자인 패턴의 쓰임새 <br>

| 패턴       | 테스트 작성 | 리팩토링 |
|----------|-------|------|
| 커맨드      | X     |      |
| 값 객체     | X     |      |
| 널 객체     |       | X    |
| 템플릿 메서드  |       | X    |
| 플러거블 객체  |       | X    |
| 플러거블 셀렉터 |       | X    |
| 펙토리 메서드  | X     | X    |
| 임포스터     | X     | X    |
| 컴포지트     | X     | X    |
| 수집 매개 변수 | X     | X    |

<br>

* 커맨드 <br>

Q. 간단한 메서드 호출보다 복잡한 형태의 계산 작업에 대한 호출이 필요하다면 어떻게 해야 할까? <br>
A. 계산 작업에 대한 객체를 생성하여 이를 호출하면 된다. <br>

메시지 하나를 보내는 것보다 호출이 조금 더 구체적이고 또 조작하기 쉬워지려면, 바로 객체가 해답이 된다. <br>
호출 자체를 나타내기 위한 객체를 만드는 것이다. <br>

<br>

* 값 객체 <br>

Q. 널리 공유해야 하지만 동일성은 중요하지 않을 때 객체를 어떤식으로 설계할 수 있을까? <br>
A. 객체가 생성될 때 객체의 상태를 설정한 후 이 상태가 절대 변할 수 없도록 한다. <br>

<br>

* 널 객체 <br>

Q. 객체의 특별한 상황을 표현하고자 할 때 어떻게 해야 할까? <br>
A. 그 특별한 상황을 표현하는 새로운 객체를 만들면 된다. <br>

<br>

* 템플릿 메서드 <br>

Q. 작업 순서는 변하지 않지만 각 작업 단위에 대한 미래의 개선 가능성을 열어두고 싶은 경우 이를 어떻게 표현할 것인가? <br>
A. 다른 메서드들을 호출하는 내용으로만 이루어진 메서드를 만든다. <br>

<br>

* 플러거블 객체 <br>

Q. 변이를 어떻게 표현할 것인가? <br>
A. 가장 간단한 방법은 명시적인 조건문을 사용하는 것이다. <br>

<br>

* 플러거블 셀렉터 <br>

Q. 인스턴스별로 서로 다른 메서드가 동적으로 호출되게 하려면 어떻게 해야 할까? <br>
A. 메서드의 이름을 저장하고 있다가 그 이름에 해당하는 메서드를 동적으로 호출한다. <br>

플러거블 셀렉터는 분명 과용될 수 있다. 가장 큰 문제는 메서드가 호출되었는지 보기 위해 코드를 추적하는 것이다. <br>
메서드를 달랑 한 개만 가지는 하위 클래스들이 한 뭉치나 존재하는, 확실히 직관적인 상황에서 코드를 정리하기 위한 <br>
용도로만 플러거블 셀렉터를 사용해야 한다. <br>

<br>

* 팩토리 메서드 <br>

Q. 새 객체를 만들 때 유연성을 원하는 경우 객체를 어떻게 생성하는가? <br>
A. 생성자를 쓰는 대신 일반 메서드에서 객체를 생성한다. <br>

<br>

* 사칭 사기꾼 <br>

Q. 기존의 코드에 새로운 변이를 도입하려면 어떻게 해야 할까? <br>
A. 기존의 객체와 같은 프로토콜을 갖지만 구현은 다른 새로운 객체를 추가한다. <br>

<br>

* 컴포지트 <br>

Q. 하나의 객체가 다른 객체 목록의 행위를 조합한 것처럼 행동하게 만들려면 어떻게 해야 할까? <br>
A. 객체 집합을 나타내는 객체를 단일 객체에 대한 임포스터로 구현한다. <br>

<br>

* 수집 매개 변수 <br>

Q. 어떤 객체에 걸쳐 존재하는 오퍼레이션의 결과를 수집하려면 어떻게 해야 할까? <br>
A. 결과가 수집될 객체를 각 오퍼레이션의 매개 변수로 추가한다. <br>

<br>

* 싱글톤 <br>

Q. 전역 변수를 제공하지 않는 언어에서 전역 변수를 사용하려면 어떻게 해야 할까? <br>
A. 사용하지 마라. <br>

<br>

### 31. 리팩토링

TDD에서는 리팩토링을 특이한 방법으로 사용한다. <br>
일반적으로 리팩토링은 어떤 상황에서도 프로그램의 의미론을 변경해서는 안 된다. <br>
하지만 TDD에서 우리가 신경 쓰는 부분은 현재 이미 통과한 테스트들뿐이다. <br>

<br>

* 차이점 일치시키기 <br>

Q. 비슷해 보이는 두 코드 조각을 합치려면 어떻게 해야 할까? <br>
A. 두 코드가 단계적으로 닮아가게끔 수정한다. <br>

1. 두 반복문의 구조가 비슷하다. 이 둘을 동일하게 만들고 나서 하나로 합친다.
2. 조건문에 의해 나눠지는 두 분기의 코드가 비슷하다. 이 둘을 동일하게 만들고 나서 조건문을 제거한다.
3. 두 클래스가 비슷하다. 이 둘을 동일하게 만들고 나서 하나를 제거한다.

간혹 차이점 일치시키기를 거구로 수행해야 하는 경우도 있다. <br>
이 말은, 변경 마지막 단계에 사소한 것만 처리하게 하려면 어떤 모양새가 되어야 할까 생각한 다음 거꾸로 거슬러 온다는 것이다. <br>

<br>

* 변화 격리하기 <br>

Q. 객체나 메서드의 일부만 바꾸려면 어떻게 해야 할까? <br>
A. 일단, 바꿔야 할 부분을 격리한다. <br>

일단 바굴 부분을 격리하고 나서 바꾸는 작업을 수행하면 작업을 되돌리기도 매우 수월하다는 사실을 알게 될 것이다. <br>
변화를 격리하기 위해 사용할 수 있는 몇 가지 방법에는 메서드 추출하기, 객체 추출하기, 메서드 객체 등이 있다. <br>

<br>

* 데이터 이주시키기 <br>

Q. 표현 양식을 변경하려면 어떻게 해야 할까? <br>
A. 일시적으로 데이터를 중복시킨다. <br>

내부에서 외부로 변화시키는 방법은 다음과 같다. <br>
1. 새로운 포맷의 인스턴스 변수를 추가한다.
2. 기존 포맷의 인스턴스 변수를 세팅하는 모든 부분에서 새로운 인스턴스 변수도 세팅하게 만든다.
3. 기존 변수를 사용하는 모든 곳에서 새 변수를 사용하게 만든다.
4. 기존 포맷을 제거한다.
5. 새 포맷에 맞게 외부 인터페이스를 변경한다.

때로는 API를 먼저 변화시키기를 원할 때도 있다. <br>
1. 새 포맷으로 인자를 하나 추가한다.
2. 새 포맷 인자에서 이전 포맷의 내부적 표현양식으로 번역한다.
3. 이전 포맷 인자를 삭제한다.
4. 이전 포맷을 사용하는 것들을 새 포맷으로 바꾼다.
5. 이전 포맷을 지운다.

<br>

* 메서드 추출하기 <br>

Q. 길고 복잡한 메서드를 읽기 쉽게 만들려면 어떻게 할까? <br>
A. 긴 메서드의 일부분을 별도의 메서드로 분리해내고 이를 호출하게 한다. <br>

메서드 추출하기는 사실 좀 더 복잡한 원자적 리팩토링의 한 가지다. <br>
1. 기존의 메서드에서 별도의 메서드로 분리할 수 있을 만한 부분을 찾아낸다. 반복문 내부의 코드나 반복문 전체, 혹은 조건문의 기자들이 일반적인 후보다.
2. 추출할 영역의 외부에서 선언된 임시 변수에 대해 할당하는 문장이 없는지 확인한다.
3. 추출할 코드를 복사해서 새 코드에 붙인다.
4. 원래 메서드에 있던 각각의 임시 변수와 매개 변수 중 새 메서드에서도 쓰이는 게 있으면, 이들을 새 메서드의 매개 변수로 추가한다.
5. 기존의 메서드에서 새 메서드를 호출한다.

<br>

* 메서드 인라인 <br>

Q. 너무 꼬여있거나 산재한 제어 흐름을 단순화하려면 어떻게 할까? <br>
A. 메서드를 호출하는 부분을 호출될 메서드의 본문으로 교체한다. <br>

1. 메서드를 복사한다.
2. 메서드 호출하는 부분을 지우고 복사한 코드를 붙인다.
3. 모든 형식 매개 변수를 실제 매개 변수로 변경한다.

<br>

* 인터페이스 추출하기 <br>

Q. 자바 오퍼레이션에 대한 두 번째 구현을 추가하려면 어떻게 해야 할까? <br>
A. 공통되는 오퍼레이션을 담고 있는 인터페이스를 만들면 된다. <br>

1. 인터페이스를 선언한다. 
2. 기존 클래스가 인터페이스를 구현하도록 만든다.
3. 필요한 메서드를 인터페이스에 추가한다.
4. 가능한 모든 곳의 타입 선언부에서 클래스 이름 대신 인터페이스 이름을 사용하게 바꾼다.

<br>

* 메서드 옮기기 <br>

Q. 메서드를 원래 있어야 할 장소로 옮기려면 어떻게 해야 할까? <br>
A. 어울리는 클래스에 메서드를 추가해주고, 그것을 호출하게 하라. <br>

1. 메서드를 복사한다.
2. 원하는 클래스에 붙이고 이름을 적절히 지어준 다음 컴파일한다.
3. 원래 객체가 메서드 내부에서 참조된다면, 원래 객체를 새 메서드의 매개 변수로 추가한다.
4. 원래 메서드의 본체를 지우고, 그곳에 새 메서드를 호출하는 코드를 넣는다.

<br>

* 메서드 객체 <br>

Q. 여러 개의 매개 변수와 지역 변수를 갖는 복잡한 메서드를 어떻게 표현할까? <br>
A. 메서드를 꺼내서 객체로 만든다. <br>

1. 메서드와 같은 매개 변수를 갖는 객체를 만든다.
2. 메서드의 지역 변수를 객체의 인스턴스 변수로 만든다.
3. 원래 메서드와 동일한 내용을 갖는 run()이라는 이름의 메서드를 만든다.
4. 원래 메서드에서는 새로 만들어진 클래스의 인스턴스를 생성하고 run()을 호출한다.

<br>

* 매개 변수 추가 <br>

Q. 메서드에 매개 변수를 추가하려면?

1. 메서드가 인터페이스에 선언되어 있다면 일단 인터페이스에 매개 변수를 추가한다.
2. 매개 변수를 추가한다.
3. 컴파일 에러가 여러분에게 어딜 고쳐야 하는지 알려줄 것이다.

<br>

* 메서드 매개 변수를 생성자 매개 변수로 바꾸기 <br>

Q. 하나 이상의 메서드의 매개 변수를 생성자로 옮기려면 어떻게 할까?

1. 생성자에 매개 변수를 추가한다.
2. 매개 변수와 같은 이름을 갖는 인스턴스 변수를 추가한다.
3. 생성자에서 인스턴스 변수의 값을 설정한다.
4. `parameter`를 `this.parameter`로 하나씩 찾아 바꾼다.
5. 매개 변수에 대한 참조가 더 이상 존재하지 않으면 해당 매개 변수를 메서드와 모든 호출자에서 제거한다.
6. 이제 필요 없어진 `this.`를 제거한다.
7. 변수명을 적절히 변경한다.

<br>

### 32. TDD 마스터하기

TDD를 각자의 습관에 통합시켜 나가는 과정에서 숙고해볼 수 있는 몇 가지 질문

* 단계가 얼마나 커야 하나? <br>

<br>

* 테스트할 필요가 없는 것은 무엇인가? <br>

<br>

* 좋은 테스트를 갖췄는지의 여부를 어떻게 알 수 있는가? <br>

<br>

* TDD로 프레임워크를 만들려면 어떻게 해야 하나? <br>

<br>

* 피드백이 얼마나 필요한가? <br>

<br>

* 테스트를 지워야 할 때는 언제인가? <br>

<br>

* 거대한 시스템을 개발할 때에도 TDD를 할 수 있는가? <br>

<br>

* 애플리케이션 수준의 테스트로도 개발을 주도할 수 있는가? <br>

<br>

* 프로젝트 중반에 TDD를 도입하려면 어떻게 해야 할까? <br>

<br>

* TDD는 누구를 위한 것인가? <br>

<br>

* TDD는 초기 조건에 민감한가? <br>

<br>

* TDD의 패턴의 관계는? <br>

<br>

* 어째서 TDD가 잘 작동하는가? <br>

<br>

* 이름을 테스트 주도 개발이라고 한 이유는? <br>

<br>

* TDD와 익스트림 프로그래밍의 실천법 사이에 어떤 관련이 있는가? <br>

<br>

* 다락의 도전? <br>

<br>


