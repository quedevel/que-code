# 🔥 [ Chapter12 ] 직렬화

## 🎯  아이템 85. 자바 직렬화의 대안을 찾으라.
직렬화의 근본적인 문제는 고역ㄱ 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다는 점이다.<br>
`ObjectInputStream`의 `readObject` 메서드를 호출하면서 객체 그래프가 역질렬화되기 때문이다.<br>
`readObject` 메서드는 클래스패스 안의 거의 모든 타입의 객체를 만들어 낼 수 있는, 마법같은 생성자다.<br>
바이트 스트림을 역질렬화하는 과정에서 이 메서드는 그 타입들 안의 모든 코드를 수행 할 수 있다. 이 말인 즉슨, <br>
그 타입들의 코드 전체가 공격 범위에 들어간다는 뜻이다. <br>

* 역직렬화 폭탄 - 이 스트림의 역질렬화는 영원히 계속된다. <br>
```java
public static void main(String[] args) throws Exception {
    byte[] bomb = bomb();
    System.out.println(bomb.length);
    deserialize(bomb());
}

static byte[] bomb() {
    Set<Object> root = new HashSet<>();
    Set<Object> s1 = root;
    Set<Object> s2 = new HashSet<>();
    for (int i = 0; i < 100; i++) {
        Set<Object> t1 = new HashSet<>();
        Set<Object> t2 = new HashSet<>();
        t1.add("foo"); // t1을 t2와 다르게 만든다.
        s1.add(t1);
        s1.add(t2);
        s2.add(t1);
        s2.add(t2);
        s1 = t1;
        s2 = t2;
    }
    return serialize(root);
}
```
이 객체 그래프는 201개의 `HashSet` 인스턴스로 구성되며, 그 각각은 3개 이하의 객체 참조를 갖는다. <br>
스트림의 전체 크기는 5,744바이트지만, 역직렬화는 태양이 불타 식을 때 까지도 끝나지 않을 것이다. <br>
<img width="30%" src="https://user-images.githubusercontent.com/55771326/175805319-23ebc628-223a-4100-84c6-13c197d089c1.PNG"><br>

따라서 새로운 시스템에서 자바 직렬화를 써야 할 이유는 전혀 없다. <br>

객체와 바이트 시퀀스를 변환해주는 다른 매커니즘이 많이 있다. <br>
그 크로스-플랫폼 구조화된 데이터 표현의 선두주자는 `JSON`과 `프로토콜 버퍼`다. <br>
둘의 가장 큰 차이는 `JSON`은 텍스트 기반이라 사람이 읽을 수 있고, `프로토콜 버퍼`는 이진 표현이라 효율이 훨씬 높다는 점이다. <br>
또한 `JSON`은 오직 데이터를 표현하는 데만 쓰이지만, `프로토콜 버퍼`는 문서를 위한 스키마를 제공하고 올바로 쓰도록 강요한다. <br>
효율은 `포로토콜 버퍼`가 훨씬 좋지만 텍스트 기반 표현에는 `JSON`이 아주 효과적이다. 또한, `프로토콜 버퍼`는 이진 표현뿐 아니라 <br>
사람이 읽을 수 있는 텍스트 표현도 지원한다. <br>


## 🎯  아이템 86. Serializable을 구현할지는 신중히 결정하라.

* `Serializable` 구현의 문제점 <br>

1️⃣ `Serializable`을 구현하면 릴리스한 뒤에는 수정하기 어렵다. <br>
클래스가 `Serializable`을 구현하면 직렬화된 바이트 스트림 인코딩도 하나의 공개 API가 된다.<br>
`private`과 `package-private` 인스턴스 필드들마저 API로 공개되는 꼴이 되어 캡슐화가 깨지게 된다.
<br>

2️⃣ 버그와 보안 구멍이 생길 위험이 높아진다.<br>
객체는 생성자를 사용해 만드는 게 기본이다. 즉, 직렬화는 언어의 기본 매커니즘을 우회하는 객체 생성 기법인 것이다.<br>
기반 방식을 따르든 재정의해 사용하든, 역직렬화는 일반 생성자의 문제가 그대로 적용되는 '숨은 생성자'다. 
<br>

3️⃣ 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다.<br>
직렬화 가능 클래스가 수정되면 신버전 인스ㅓㄴ스를 직렬화한 후 구버전으로 역직렬화할 수 있는지,<br>
그리고 그 반대도 가능한지를 검사해야 한다. 따라서 테스트해야 할 양이 직렬화 가능 클래스의 수와 릴리스 횟수에 비례해 증가한다.
<br>

`Serializable`은 구현한다고 선언하기는 아주 쉽지만, 그것은 눈속임일 뿐이다. 한 클래스의 여러 버전이 상호작용할 일이 없고 <br>
서버가 신뢰할 수 없는 데이터에 노출될 가능성이 없는 등, 보호된 환경에서만 쓰일 클래스가 아니라면 `Serializable`구현은 아주 <br>
신중하게 이뤄져야 한다. 상속할 수 있는 클래스라면 주의사항이 더욱 많아진다. <br>

## 🎯  아이템 87. 커스텀 직렬화 형태를 고려해보라.
## 🎯  아이템 88. readObject 메서드는 방어적으로 작성하라.
## 🎯  아이템 89. 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라.
## 🎯  아이템 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라.

<br>

> Joshua Bloch, 『Effective Java 3/E』, 개앞맵시 옮김, 프로그래밍인사이트(2018), p449-482.