## 단위 테스트.

<br>

#### 깨끗한 테스트 코드 유지하기

**_테스트는 유연성, 유지보수성, 재사용성을 제공한다._** <br>
테스트 코드를 깨긋하게 유지하지 않으면 결국은 잃어버린다. <br>
그리고 테스트 케이스가 없으면 실제 코드를 유연하게 만드는 버팀목도 사라진다. <br>
코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위테스트다. 이유는 단순하다. <br>
테스트 케이스가 있으면 변경이 두렵지 않다. 테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. <br>

<br>

#### 깨끗한 테스트 코드

깨끗한 테스트 코드를 만들려면 세 가지가 필요하다. 가독성, 가독성, 가독성.

**_도메인에 특화된 테스트 언어_** <br>
흔히 쓰는 시스템 조작 API를 사용하는 대신 API 위에다 함수와 유틸리티를 구현 후 <br>
그 함수와 유틸리티를 사용하므로 테스트 코드를 짜기도 읽기도 쉬워진다. <br>
이렇게 구현한 함수와 유틸리티는 테스트 코드에서 사용하는 특수 API가 된다. <br>
즉, 테스트를 구현하는 당사자와 나중에 테스트를 읽어볼 독자를 도와주는 테스트 언어다. <br>

<br>

**_이중 표준_** <br>
단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없다. <br>
실제 환경이 아니라 테스트 환경에서 돌아가는 코드이기 때문이다. 실제 환경과 테스트 환경은 요구사항이 팔이하게 다르다. <br>

<br>

#### 테스트 당 assert 하나

assert 문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다. <br>
함수 이름을 바꿔 given-when-then 이라는 관례를 사용하면 코드를 읽기가 쉬워진다. 불행하게도, 테스트를 분리하면 중복되는 코드가 많아진다. <br>
템플릿 메소드 패턴을 사용하면 중복을 제거할 수 있다. given/when 부분을 부모 클래스에 두고 then 부분을 자식 클래스에 두면 된다. <br>
아니면 완전히 독자적인 테스트 클래스를 만들어 @Before 함수에 given/when 부분을 넣고 @Test 함수에 then 부분을 넣어도 된다. <br>

<br>

#### 깨끗한 테스트의 다섯 가지 규칙 F.I.R.S.T


**빠르게(Fast)** : 테스트는 빨라야 한다. 자주 돌릴 수 있어야 하며 마음껏 정리할 수 있어야 한다. <br>
**_독립적으로(Independent)_** : 각 테스트는 서로 의존하면 안 된다. 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안 된다. <br>
**_반복가능하게(Repeatable)_** : 테스트는 어떤 환경에서도 반복 가능해야 한다. <br>
**_자가검증하는(Self-Validating)_** : 테스트는 부울(bool)값으로 결과를 내야 한다. 성공 아니면 실패다. <br>
**_적시에(Timely)_** : 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. <br>


<br>

> Robert C. Martin, 『Clean Code』, 박재호 * 이해영 옮김, 인사이트(2013), p154-169.